<!DOCTYPE html>
<html>
    <head>
        <title>Sorting Algorithms</title>
        <meta charset="UTF-8">
        <link rel="icon" type="image/png" href="icon.png">
        <link rel="stylesheet" href="style.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
    </head>
    <body>
        <h1 class="page-title">Learn Sorting Algorithms</h1>
        <div class="separator"></div>
        <h2 class="section-title">Sorting Algorithm Visualizer</h2>
        <div class="buttons-container">
            <button id="merge-sort" class="buttons">Merge Sort</button>
            <button id="shell-sort" class="buttons">Shell Sort</button>
            <button id="radix-sort" class="buttons">Radix Sort</button>
            <button id="quick-sort" class="buttons">Quick Sort</button>
            <button id="selection-sort" class="buttons">Selection Sort</button>
            <button id="insertion-sort" class="buttons">Insertion Sort</button>
            <button id="entropy" class="buttons">Randomize</button>
        </div>
        <div class="container">
            <div class="element" id="el_1"></div>
            <div class="element" id="el_2"></div>
            <div class="element" id="el_3"></div>
            <div class="element" id="el_4"></div>
            <div class="element" id="el_5"></div>
            <div class="element" id="el_6"></div>
            <div class="element" id="el_7"></div>
            <div class="element" id="el_8"></div>
            <div class="element" id="el_9"></div>
            <div class="element" id="el_10"></div>
            <div class="element" id="el_11"></div>
            <div class="element" id="el_12"></div>
            <div class="element" id="el_13"></div>
            <div class="element" id="el_14"></div>
            <div class="element" id="el_15"></div>
            <div class="element" id="el_16"></div>
            <div class="element" id="el_17"></div>
            <div class="element" id="el_18"></div>
            <div class="element" id="el_19"></div>
            <div class="element" id="el_20"></div>
            <div class="element" id="el_21"></div>
            <div class="element" id="el_22"></div>
            <div class="element" id="el_23"></div>
            <div class="element" id="el_24"></div>
            <div class="element" id="el_25"></div>
            <div class="element" id="el_26"></div>
            <div class="element" id="el_27"></div>
            <div class="element" id="el_28"></div>
            <div class="element" id="el_29"></div>
            <div class="element" id="el_30"></div>
            <div class="element" id="el_31"></div>
            <div class="element" id="el_32"></div>
            <div class="element" id="el_33"></div>
            <div class="element" id="el_34"></div>
            <div class="element" id="el_35"></div>
            <div class="element" id="el_36"></div>
            <div class="element" id="el_37"></div>
            <div class="element" id="el_38"></div>
            <div class="element" id="el_39"></div>
            <div class="element" id="el_40"></div>
            <div class="element" id="el_41"></div>
            <div class="element" id="el_42"></div>
            <div class="element" id="el_43"></div>
            <div class="element" id="el_44"></div>
            <div class="element" id="el_45"></div>
            <div class="element" id="el_46"></div>
            <div class="element" id="el_47"></div>
            <div class="element" id="el_48"></div>
            <div class="element" id="el_49"></div>
            <div class="element" id="el_50"></div>
            <div class="element" id="el_51"></div>
            <div class="element" id="el_52"></div>
            <div class="element" id="el_53"></div>
            <div class="element" id="el_54"></div>
            <div class="element" id="el_55"></div>
            <div class="element" id="el_56"></div>
            <div class="element" id="el_57"></div>
            <div class="element" id="el_58"></div>
            <div class="element" id="el_59"></div>
            <div class="element" id="el_60"></div>
        </div>
        <div class="algorithms-container">
            <h2 class="section-title" id="pi">Principles and Implementations</h2>
            <details>
                <summary class="algorithms">Merge Sort</summary>
                <p class="algorithm-description">Merge sort is a sorting algorithm that divides a list into two halves, recursively sorts each half, and then merges the sorted halves to produce a sorted list. The recursive partitioning continues until a list of 1 element is reached, as list of 1 element is already sorted.</p>
                <p class="algorithm-description">Sample Implementation:</p>
                <div class="code-snippet">
                    void Merge(int numbers[], int i, int j, int k) {<br>
                        int mergedSize;                            // Size of merged partition<br>
                        int mergePos;                              // Position to insert merged number<br>
                        int leftPos;                               // Position of elements in left partition<br>
                        int rightPos;                              // Position of elements in right partition<br>
                        int* mergedNumbers = nullptr;<br><br>
                     
                        mergePos = 0;<br>
                        mergedSize = k - i + 1;<br>
                        leftPos = i;                               // Initialize left partition position<br>
                        rightPos = j + 1;                          // Initialize right partition position<br>
                        mergedNumbers = new int[mergedSize];       // Dynamically allocates temporary array<br>
                                                                   // for merged numbers<br><br>
                        
                        // Add smallest element from left or right partition to merged numbers<br>
                        while (leftPos <= j && rightPos <= k) {<br>
                           if (numbers[leftPos] < numbers[rightPos]) {<br>
                              mergedNumbers[mergePos] = numbers[leftPos];<br>
                              ++leftPos;<br>
                           }<br>
                           else {
                              mergedNumbers[mergePos] = numbers[rightPos];<br>
                              ++rightPos;
                              <br>
                           }<br>
                           ++mergePos;<br>
                        }<br><br>
                        
                        // If left partition is not empty, add remaining elements to merged numbers<br>
                        while (leftPos <= j) {<br>
                           mergedNumbers[mergePos] = numbers[leftPos];<br>
                           ++leftPos;<br>
                           ++mergePos;<br>
                        }<br><br>
                        
                        // If right partition is not empty, add remaining elements to merged numbers<br>
                        while (rightPos <= k) {<br>
                           mergedNumbers[mergePos] = numbers[rightPos];<br>
                           ++rightPos;<br>
                           ++mergePos;<br>
                        }<br><br>
                        
                        // Copy merge number back to numbers<br>
                        for (mergePos = 0; mergePos < mergedSize; ++mergePos) {<br>
                           numbers[i + mergePos] = mergedNumbers[mergePos];<br>
                        }<br>
                        delete[] mergedNumbers;<br>
                     }<br>
                     
                     void MergeSort(int numbers[], int i, int k) {<br>
                        int j;<br><br>
                        
                        if (i < k) {<br>
                           j = (i + k) / 2;  // Find the midpoint in the partition<br>
                           <br>
                           // Recursively sort left and right partitions<br>
                           MergeSort(numbers, i, j);<br>
                           MergeSort(numbers, j + 1, k);<br>
                           <br>
                           // Merge left and right partition in sorted order<br>
                           Merge(numbers, i, j, k);<br>
                        }<br>
                     }
                </div>
            </details>
            <details>
                <summary class="algorithms">Shell Sort</summary>
                <p class="algorithm-description">Shell sort is a sorting algorithm that treats the input as a collection of interleaved lists, and sorts each list individually with a variant of the insertion sort algorithm. Shell sort uses gap values to determine the number of interleaved lists. A gap value is a positive integer representing the distance between elements in an interleaved list. For each interleaved list, if an element is at index i, the next element is at index i + gap value.
                    Shell sort begins by choosing a gap value K and sorting K interleaved lists in place. Shell sort finishes by performing a standard insertion sort on the entire array. Because the interleaved parts have already been sorted, smaller elements will be close to the array's beginning and larger elements towards the end. Insertion sort can then quickly sort the nearly-sorted array.
                    Any positive integer gap value can be chosen. In the case that the array size is not evenly divisible by the gap value, some interleaved lists will have fewer items than others.
                    </p>
                <p class="algorithm-description">Sample Implementation:</p>
                <div class="code-snippet">
                    InsertionSortInterleaved(numbers, numbersSize, startIndex, gap) {<br>
                        i = 0<br>
                        j = 0<br>
                        temp = 0  // Temporary variable for swap<br><br>
                     
                        for (i = startIndex + gap; i < numbersSize; i = i + gap) {<br>
                           j = i<br>
                           while (j - gap >= startIndex && numbers[j] < numbers[j - gap]) {<br>
                              temp = numbers[j]<br>
                              numbers[j] = numbers[j - gap]<br>
                              numbers[j - gap] = temp<br>
                              j = j - gap<br>
                           }<br>
                        }<br>
                     }<br><br>
                     ShellSort(numbers, numbersSize, gapValues) {<br>
                        for each (gapValue in gapValues) {<br>
                           for (i = 0; i < gapValue; i++) {<br>
                              InsertionSortInterleaved(numbers, numbersSize, i, gapValue)<br>
                           }<br>
                        }<br>
                     }
                     
                </div>
            </details>
            <details>
                <summary class="algorithms">Radix Sort</summary>
                <p class="algorithm-description">Radix sort is a sorting algorithm specifically for an array of integers: The algorithm processes one digit at a time starting with the least significant digit and ending with the most significant. Two steps are needed for each digit. First, all array elements are placed into buckets based on the current digit's value. Then, the array is rebuilt by removing all elements from buckets, in order from lowest bucket to highest.</p>
                <p class="algorithm-description">Sample Implementation:</p>
                <div class="code-snippet">
                    // Returns the maximum length, in number of digits, out of all elements in the array<br><br>
                    RadixGetMaxLength(array, arraySize) {<br>
                       maxDigits = 0<br>
                       for (i = 0; i < arraySize; i++) {<br>
                          digitCount = RadixGetLength(array[i])<br>
                          if (digitCount > maxDigits)<br>
                             maxDigits = digitCount<br>
                       }<br>
                       return maxDigits<br>
                    }<br><br>
                    
                    // Returns the length, in number of digits, of value<br>
                    RadixGetLength(value) {<br>
                       if (value == 0)<br>
                          return 1<br><br>
                    
                       digits = 0<br>
                       while (value != 0) {<br>
                          digits = digits + 1<br>
                          value = value / 10<br>
                       }<br>
                       return digits<br>
                    }<br><br>
                    RadixSort(array, arraySize) {<br>
                        buckets = create array of 10 buckets<br><br>
                     
                        // Find the max length, in number of digits<br>
                        maxDigits = RadixGetMaxLength(array, arraySize)<br><br>
                           
                        // Start with the least significant digit<br>
                        pow10 = 1<br>
                        for (digitIndex = 0; digitIndex < maxDigits; digitIndex++) {<br>
                           for (i = 0; i < arraySize; i++) {<br>
                              bucketIndex = abs(array[i] / pow10) % 10<br>
                              Append array[i] to buckets[bucketIndex]<br>
                           }<br>
                           arrayIndex = 0<br>
                           for (i = 0; i < 10; i++) {<br>
                              for (j = 0; j < buckets[i]â‡¢size(); j++)<br>
                                 array[arrayIndex++] = buckets[i][j]<br>
                           }<br>
                           pow10 = 10 * pow10<br>
                           Clear all buckets<br>
                        }<br>
                     }<br>
                </div>
            </details>
            <details>
                <summary class="algorithms">Quick Sort</summary>
                <p class="algorithm-description">Quicksort is a sorting algorithm that repeatedly partitions the input into low and high parts (each part unsorted), and then recursively sorts each of those parts. To partition the input, quicksort chooses a pivot to divide the data into low and high parts. The pivot can be any value within the array being sorted, commonly the value of the middle array element. Ex: For the list {4 34 10 25 1}, the middle element is located at index 2 (the middle of indices 0..4) and has a value of 10.
                    To partition the input, the quicksort algorithm divides the array into two parts, referred to as the low partition and the high partition. All values in the low partition are less than or equal to the pivot value. All values in the high partition are greater than or equal to the pivot value. The values in each partition are not necessarily sorted. Ex: Partitioning {4 34 10 25 1} with a pivot value of 10 results in a low partition of {4 10 1} and a high partition of {34 25}. Values equal to the pivot may appear in either or both of the partitions.
                    </p>
                <p class="algorithm-description"> Sample Implementation:</p>
                <div class="code-snippet">
                    int Partition(int numbers[], int i, int k) {<br>
                        int l;<br>
                        int h;<br>
                        int midpoint;<br>
                        int pivot;<br>
                        int temp;<br>
                        bool done;<br><br>
                        
                        /* Pick middle element as pivot */<br>
                        midpoint = i + (k - i) / 2;<br>
                        pivot = numbers[midpoint];<br><br>
                        
                        done = false;<br>
                        l = i;<br>
                        h = k;<br>
                        
                        while (!done) {<br>
                           
                           /* Increment l while numbers[l] &lt pivot */<br>
                           while (numbers[l] &lt pivot) {<br>
                              ++l;<br>
                           }<br><br>
                           
                           /* Decrement h while pivot < numbers[h] */<br>
                           while (pivot < numbers[h]) {<br>
                              --h;<br>
                           }<br><br>
                           
                           /* If there are zero or one elements remaining,<br>
                            all numbers are partitioned. Return h */<br>
                           if (l >= h) {<br>
                              done = true;<br>
                           }<br>
                           else {<br>
                              /* Swap numbers[l] and numbers[h],<br>
                               update l and h */<br>
                              temp = numbers[l];<br>
                              numbers[l] = numbers[h];<br>
                              numbers[h] = temp;<br><br>
                              
                              ++l;<br>
                              --h;<br>
                           }<br>
                        }<br><br>
                        
                        return h;<br>
                     }<br><br>
                     
                     void Quicksort(int numbers[], int i, int k) {<br>
                        int j;<br><br>
                        
                        /* Base case: If there are 1 or zero elements to sort,<br>
                         partition is already sorted */<br>
                        if (i >= k) {<br>
                           return;<br>
                        }<br><br>
                        
                        /* Partition the data within the array. Value j returned<br>
                         from partitioning is location of last element in low partition. */<br>
                        j = Partition(numbers, i, k);<br><br>
                        
                        /* Recursively sort low partition (i to j) and<br>
                         high partition (j + 1 to k) */<br>
                        Quicksort(numbers, i, j);<br>
                        Quicksort(numbers, j + 1, k);<br>
                     }
                </div>
            </details>
            <details>
                <summary class="algorithms">Selection Sort</summary>
                <p class="algorithm-description">Selection sort is a sorting algorithm that treats the input as two parts, a sorted part and an unsorted part, and repeatedly selects the proper next value to move from the unsorted part to the end of the sorted part.</p>
                <p class="algorithm-description"> Sample Implementation:</p>
                <div class="code-snippet">
                    for (i = 0; i < numbersSize - 1; ++i) {<br><br>

                        // Find index of smallest remaining element<br>
                        indexSmallest = i;<br>
                        for (j = i + 1; j < numbersSize; ++j) {<br><br>
                     
                           if (numbers[j] < numbers[indexSmallest]) {<br>
                              indexSmallest = j;<br>
                           }<br>
                        }<br><br>
                     
                        // Swap numbers[i] and numbers[indexSmallest]<br>
                        temp = numbers[i];<br>
                        numbers[i] = numbers[indexSmallest];<br>
                        numbers[indexSmallest] = temp;<br>
                     }
                </div>
            </details>
            <details>
                <summary class="algorithms">Insertion Sort</summary>
                <p class="algorithm-description">Insertion sort is a sorting algorithm that treats the input as two parts, a sorted part and an unsorted part, and repeatedly inserts the next value from the unsorted part into the correct location in the sorted part.</p>
                <p class="algorithm-description"> Sample Implementation:</p>
                <div class="code-snippet">
                    for (i = 1; i < numbersSize; ++i) {<br>
                        j = i;<br>
                        // Insert numbers[i] into sorted part<br>
                        // stopping once numbers[i] in correct position<br>
                        while (j > 0 && numbers[j] < numbers[j - 1]) {<br><br>
                          
                           // Swap numbers[j] and numbers[j - 1]<br>
                           temp = numbers[j];<br>
                           numbers[j] = numbers[j - 1];<br>
                           numbers[j - 1] = temp;<br>
                           --j;<br>
                        }<br>
                     }               
                </div>
            </details>
        </div>
    </body>

    <script src="script.js"></script>
</html>